<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构-实验二 | 寻觅~流光</title><meta name="author" content="寻觅~流光"><meta name="copyright" content="寻觅~流光"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构-实验二二叉树的操作与实现1、二叉树的基本操作算法实现 (1) 利用(广义表)二叉树字符串“A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))”创建二叉树 的二叉链式存储结构；(请勿根据扩展二叉树进行创建)   (2) 输出该二叉树(中序遍历序列)；   (3) 输出‘H’结点的左、右孩子结点值；   (4) 输出该二叉树的结点个数、叶子结点个数、二叉树的度和高度。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构-实验二">
<meta property="og:url" content="https://8023time.github.io/2024/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%BA%8C/index.html">
<meta property="og:site_name" content="寻觅~流光">
<meta property="og:description" content="数据结构-实验二二叉树的操作与实现1、二叉树的基本操作算法实现 (1) 利用(广义表)二叉树字符串“A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))”创建二叉树 的二叉链式存储结构；(请勿根据扩展二叉树进行创建)   (2) 输出该二叉树(中序遍历序列)；   (3) 输出‘H’结点的左、右孩子结点值；   (4) 输出该二叉树的结点个数、叶子结点个数、二叉树的度和高度。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png">
<meta property="article:published_time" content="2024-11-24T16:00:00.000Z">
<meta property="article:modified_time" content="2024-12-08T10:59:04.470Z">
<meta property="article:author" content="寻觅~流光">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/basic-img/avatar.jpg"><link rel="canonical" href="https://8023time.github.io/2024/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%BA%8C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 8 || hour >= 21
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构-实验二',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-08 18:59:04'
}</script><link rel="stylesheet" href="/css/universe.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/basic-img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友联</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/basic-img/avatar.jpg" alt="Logo"><span class="site-name">寻觅~流光</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构-实验二</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友联</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构-实验二</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-11-24T16:00:00.000Z" title="发表于 2024-11-25 00:00:00">2024-11-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构-实验二"><a href="#数据结构-实验二" class="headerlink" title="数据结构-实验二"></a>数据结构-实验二</h1><h2 id="二叉树的操作与实现"><a href="#二叉树的操作与实现" class="headerlink" title="二叉树的操作与实现"></a>二叉树的操作与实现</h2><h3 id="1、二叉树的基本操作算法实现"><a href="#1、二叉树的基本操作算法实现" class="headerlink" title="1、二叉树的基本操作算法实现"></a>1、二叉树的基本操作算法实现</h3><blockquote>
<p>(1) 利用(广义表)二叉树字符串“A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))”创建二叉树 的二叉链式存储结构；(请勿根据扩展二叉树进行创建)  </p>
<p>(2) 输出该二叉树(中序遍历序列)；  </p>
<p>(3) 输出‘H’结点的左、右孩子结点值；  </p>
<p>(4) 输出该二叉树的结点个数、叶子结点个数、二叉树的度和高度。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、二叉树的各种遍历算法实现"><a href="#2、二叉树的各种遍历算法实现" class="headerlink" title="2、二叉树的各种遍历算法实现"></a>2、二叉树的各种遍历算法实现</h3><blockquote>
<p>实现上述二叉树的先序、中序和后序遍历的递归和非递归算法。 </p>
</blockquote>
<h5 id="1-先序-中序的非递归遍历"><a href="#1-先序-中序的非递归遍历" class="headerlink" title="1.先序,中序的非递归遍历"></a>1.先序,中序的非递归遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;<span class="comment">// 数据</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Tree</span>* leftchild;<span class="comment">// 左子树</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Tree</span>* rightchild;<span class="comment">// 右子树</span></span><br><span class="line">&#125;tree, * treelist;</span><br><span class="line"><span class="comment">// 栈的创建</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stacknode</span> &#123;</span><br><span class="line">	tree* data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stacknode</span>* next;</span><br><span class="line">&#125;node, * stack;</span><br><span class="line"><span class="comment">// 二叉树的创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTree</span><span class="params">(treelist&amp; app)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">		app = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		app = <span class="keyword">new</span> Tree;</span><br><span class="line">		app-&gt;data = ch;</span><br><span class="line">		<span class="built_in">createTree</span>(app-&gt;leftchild);</span><br><span class="line">		<span class="built_in">createTree</span>(app-&gt;rightchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initstack</span><span class="params">(stack root)</span> </span>&#123;</span><br><span class="line">	root-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">	root-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在栈中加入一些数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushstack</span><span class="params">(stack root, tree* app)</span> </span>&#123;</span><br><span class="line">	node* stackapp = (node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">	stackapp-&gt;data = app;</span><br><span class="line">	stackapp-&gt;next = root-&gt;next;</span><br><span class="line">	root-&gt;next = stackapp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">(stack root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将栈中的数据拿出来</span></span><br><span class="line"><span class="function">node* <span class="title">popstack</span><span class="params">(stack root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isempty</span>(root)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		node* app = root-&gt;next;</span><br><span class="line">		root-&gt;next = app-&gt;next;</span><br><span class="line">		<span class="keyword">return</span> app;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="comment">// 基本思想很简单</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(treelist app)</span> </span>&#123;</span><br><span class="line">	treelist APP = app;</span><br><span class="line">	stack stackAPP = <span class="keyword">new</span> node;</span><br><span class="line">	<span class="built_in">initstack</span>(stackAPP);</span><br><span class="line">	<span class="keyword">while</span> (APP || !<span class="built_in">isempty</span>(stackAPP)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (APP) &#123;</span><br><span class="line">			cout &lt;&lt; APP-&gt;data &lt;&lt; <span class="string">&quot;---&quot;</span>;</span><br><span class="line">			<span class="built_in">pushstack</span>(stackAPP, APP);</span><br><span class="line">			APP = APP-&gt;leftchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			APP = <span class="built_in">popstack</span>(stackAPP)-&gt;data;</span><br><span class="line">			APP = APP-&gt;rightchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="comment">// 基本思想就是到左子树遍历到null的时候就出栈,打印出数据,只要为空就打印出栈中的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(treelist app)</span> </span>&#123;</span><br><span class="line">	treelist APP = app;</span><br><span class="line">	stack stackAPP = <span class="keyword">new</span> node;</span><br><span class="line">	<span class="built_in">initstack</span>(stackAPP);</span><br><span class="line">	<span class="keyword">while</span> (APP || !<span class="built_in">isempty</span>(stackAPP)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (APP) &#123;</span><br><span class="line">			<span class="built_in">pushstack</span>(stackAPP, APP);</span><br><span class="line">			APP = APP-&gt;leftchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			APP = <span class="built_in">popstack</span>(stackAPP)-&gt;data;</span><br><span class="line">			cout &lt;&lt; APP-&gt;data &lt;&lt; <span class="string">&quot;---&quot;</span>;</span><br><span class="line">			APP = APP-&gt;rightchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	treelist app;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入二叉树的数据&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">createTree</span>(app);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;先序遍历:&quot;</span>;</span><br><span class="line">	<span class="built_in">preorder</span>(app);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;中序遍历:&quot;</span>;</span><br><span class="line">	<span class="built_in">inorder</span>(app);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-后序遍历的非递归的方法"><a href="#2-后序遍历的非递归的方法" class="headerlink" title="2.后序遍历的非递归的方法"></a>2.后序遍历的非递归的方法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tree</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tree</span>* lefttree, * righttree;</span><br><span class="line">	<span class="type">bool</span> flage;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义一个栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stack</span> &#123;</span><br><span class="line">	tree* data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stack</span>* next;</span><br><span class="line">&#125;*stacknode;</span><br><span class="line"><span class="comment">// 创建一个二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createtree</span><span class="params">(tree*&amp; app)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	cin &gt;&gt; data;</span><br><span class="line">	<span class="keyword">if</span> (data == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">		app = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		app = <span class="keyword">new</span> tree;</span><br><span class="line">		app -&gt; data = data;</span><br><span class="line">		app-&gt;flage = <span class="literal">false</span>;</span><br><span class="line">		<span class="built_in">createtree</span>(app-&gt;lefttree);</span><br><span class="line">		<span class="built_in">createtree</span>(app-&gt;righttree);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化一个栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initstack</span><span class="params">(stacknode &amp;app)</span> </span>&#123;</span><br><span class="line">	app-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">	app-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给栈加入一个数据到栈里面去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addstack</span><span class="params">(stacknode&amp; app, tree* data)</span> </span>&#123;</span><br><span class="line">	stacknode node = <span class="keyword">new</span> stack;</span><br><span class="line">	node-&gt;data = data;</span><br><span class="line">	node-&gt;next = app-&gt;next;</span><br><span class="line">	app-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 栈弹出来一个元素</span></span><br><span class="line"><span class="function">tree* <span class="title">popstack</span><span class="params">(stacknode&amp; app)</span> </span>&#123;</span><br><span class="line">	tree* data = app-&gt;next-&gt;data;</span><br><span class="line">	stacknode number = app-&gt;next;</span><br><span class="line">	app-&gt;next = number-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> number;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查看栈头顶的那个元素</span></span><br><span class="line"><span class="function">tree* <span class="title">checkstack</span><span class="params">(stacknode&amp; app)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> app-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">(stacknode&amp; app)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (app-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线索化二叉树	</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(tree* app)</span> </span>&#123;</span><br><span class="line">	tree* APP = app;</span><br><span class="line">	stacknode stackdata = <span class="keyword">new</span> stack;</span><br><span class="line">	<span class="built_in">initstack</span>(stackdata);</span><br><span class="line">		<span class="keyword">while</span> (APP || !<span class="built_in">isempty</span>(stackdata)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (APP) &#123;</span><br><span class="line">				<span class="built_in">addstack</span>(stackdata, APP);</span><br><span class="line">				APP = APP-&gt;lefttree;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				tree* top = <span class="built_in">checkstack</span>(stackdata);</span><br><span class="line">				<span class="keyword">if</span> (top-&gt;righttree &amp;&amp; top-&gt;righttree-&gt;flage == <span class="literal">false</span>) &#123;<span class="comment">// 判断右节点是否被访问过,没有的户就把这个右节点存储到栈中</span></span><br><span class="line">					top = top-&gt;righttree;</span><br><span class="line">					<span class="built_in">addstack</span>(stackdata, top);</span><br><span class="line">					APP = top-&gt;lefttree;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					tree* topdata = <span class="built_in">popstack</span>(stackdata);</span><br><span class="line">					cout &lt;&lt; topdata-&gt;data &lt;&lt; <span class="string">&quot;---&quot;</span>;</span><br><span class="line">					topdata-&gt;flage = <span class="literal">true</span>;<span class="comment">// 标记这个节点已经被访问过,后面不用再次访问这个节点了</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	tree* app;</span><br><span class="line">	<span class="built_in">createtree</span>(app);<span class="comment">//创建一个二叉树</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;后序遍历二叉树采用非递归的方法:&quot;</span>;</span><br><span class="line">	<span class="built_in">postorder</span>(app);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、线索二叉树的遍历"><a href="#3、线索二叉树的遍历" class="headerlink" title="3、线索二叉树的遍历"></a>3、线索二叉树的遍历</h3><blockquote>
<p>中序线索化上述二叉树并找出根结点的前驱和后继。 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiThrNode</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;<span class="comment">// 数据</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiThrNode</span>* leftchild;<span class="comment">// 左指针</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiThrNode</span>* rightchild;<span class="comment">// 右指针</span></span><br><span class="line">	<span class="type">int</span> LTag; <span class="comment">// 左标志</span></span><br><span class="line">	<span class="type">int</span> RTag; <span class="comment">// 右标志</span></span><br><span class="line">&#125;BiThrNode, * BiThrTree;</span><br><span class="line"><span class="comment">// 全局定义一个线索化二叉树的一个全局变量</span></span><br><span class="line">BiThrNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 二叉树的创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTree</span><span class="params">(BiThrTree&amp; app)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">		app = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		app = <span class="keyword">new</span> BiThrNode;</span><br><span class="line">		app-&gt;data = ch;</span><br><span class="line">		app-&gt;LTag = <span class="number">0</span>;</span><br><span class="line">		app-&gt;RTag = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">createTree</span>(app-&gt;leftchild);</span><br><span class="line">		<span class="built_in">createTree</span>(app-&gt;rightchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线索化中序二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">middleTree</span><span class="params">(BiThrTree &amp;app)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (app) &#123;</span><br><span class="line">		<span class="built_in">middleTree</span>(app-&gt;leftchild);</span><br><span class="line">		<span class="comment">// 在这里写一些线索化的代码</span></span><br><span class="line">		<span class="keyword">if</span> (!app-&gt;leftchild) &#123;<span class="comment">// 如果左子树为空,线索化左子树</span></span><br><span class="line">			app-&gt;LTag = <span class="number">1</span>;</span><br><span class="line">			app-&gt;leftchild = pre;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rightchild == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果pre的右子树为空的话,线索化最下面的这个节点前驱后继之类</span></span><br><span class="line">			pre-&gt;RTag = <span class="number">1</span>;</span><br><span class="line">			pre-&gt;rightchild = app;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = app;</span><br><span class="line">		<span class="built_in">middleTree</span>(app-&gt;rightchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面就是遍历线索化中序二叉树的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">middleprintf</span><span class="params">(BiThrTree&amp; app)</span> </span>&#123;</span><br><span class="line">	BiThrNode* current = app;</span><br><span class="line">	<span class="keyword">while</span> (current &amp;&amp; current-&gt;LTag == <span class="number">0</span>) &#123;</span><br><span class="line">		current = current-&gt;leftchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (current) &#123;</span><br><span class="line">		cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot;---&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;RTag == <span class="number">1</span>) &#123;</span><br><span class="line">			current = current-&gt;rightchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			current = current-&gt;rightchild;</span><br><span class="line">			<span class="keyword">while</span> (current &amp;&amp; current-&gt;LTag == <span class="number">0</span>) &#123;</span><br><span class="line">				current = current-&gt;leftchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BiThrTree app;</span><br><span class="line">	<span class="built_in">createTree</span>(app);</span><br><span class="line">	<span class="built_in">middleTree</span>(app);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线索化中序二叉树的遍历为:&quot;</span>;</span><br><span class="line">	<span class="built_in">middleprintf</span>(app);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4、构造哈夫曼树HT、哈夫曼编码HC、哈夫曼译码的算法实现。"><a href="#4、构造哈夫曼树HT、哈夫曼编码HC、哈夫曼译码的算法实现。" class="headerlink" title="4、构造哈夫曼树HT、哈夫曼编码HC、哈夫曼译码的算法实现。"></a>4、构造哈夫曼树HT、哈夫曼编码HC、哈夫曼译码的算法实现。</h3><blockquote>
<p>在发送端，统计下面一段英文的不同字符个数和每个字符的出现频率，利用统 计数据构造构造哈夫曼树和哈夫曼编码；在接收端，将接收到的 0-1 序列恢复成英 文段落。  </p>
<p>The Chinese official said he viewed the Trump Presidency not as an  aberration but as the product of a failing political system. This jibes with other  accounts. The Chinese leadership believes that the United States, and Western  democracies in general, haven’t risen to the challenge of a globalized economy,  which necessitates big changes in production patterns, as well as major upgrades  in education and public infrastructure. In Trump and Trumpism, the Chinese see  an inevitable backlash to this failure.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;dataweight;<span class="comment">// 存储权值的map容器</span></span><br><span class="line">map&lt;<span class="type">char</span>, string&gt;datacode;<span class="comment">// 存储01数据的</span></span><br><span class="line">map&lt;string, <span class="type">char</span>&gt;codedatainformation;<span class="comment">// 存储01对应的字符</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_size 9999</span></span><br><span class="line">string stargeinformation;<span class="comment">// 用来存储文章的内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">// 定义哈夫曼树</span></span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="type">int</span> parent;</span><br><span class="line">	<span class="type">int</span> leftchild;</span><br><span class="line">	<span class="type">int</span> rightchild;</span><br><span class="line">&#125;Huffmannode,*HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getweight</span><span class="params">(string&amp; app)</span> </span>&#123;<span class="comment">// 获取文章的各个字符的权重</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> spp : app) &#123;</span><br><span class="line">		dataweight[spp]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">CreateHuffmanTree</span><span class="params">(<span class="type">int</span> length)</span> </span>&#123;<span class="comment">// 创建一个哈夫曼树</span></span><br><span class="line">	<span class="type">int</span> totallength = length * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">	HuffmanTree tree = (HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Huffmannode) * (totallength));<span class="comment">// 首先要分配内存</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; totallength;i++) &#123;<span class="comment">//初始化所有的节点</span></span><br><span class="line">		tree[i].weight = <span class="number">0</span>;</span><br><span class="line">		tree[i].leftchild = <span class="number">-1</span>;</span><br><span class="line">		tree[i].rightchild = <span class="number">-1</span>;</span><br><span class="line">		tree[i].parent = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;<span class="comment">//前面的length个节点要进行填充操作</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : dataweight) &#123;</span><br><span class="line">		tree[index++].weight = it.second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = length;i &lt; totallength;i++) &#123;<span class="comment">// 接下来就是构造哈夫曼树</span></span><br><span class="line">		<span class="type">int</span> minnumber1 = <span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> minnumber2 = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tree[j].parent == <span class="number">-1</span>) &#123;<span class="comment">// 如果在这个哈夫曼书中找到了这个父节点没有的节点的话就通过</span></span><br><span class="line">				<span class="keyword">if</span> (minnumber1 == <span class="number">-1</span> || tree[minnumber1].weight &gt; tree[j].weight) &#123;<span class="comment">// 找到两个最小的节点</span></span><br><span class="line">					minnumber2 = minnumber1;</span><br><span class="line">					minnumber1 = j;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (minnumber2 == <span class="number">-1</span> || tree[minnumber2].weight &gt; tree[j].weight) &#123;</span><br><span class="line">					minnumber2 = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tree[i].weight = tree[minnumber1].weight + tree[minnumber2].weight;</span><br><span class="line">		tree[i].leftchild = minnumber1;</span><br><span class="line">		tree[i].rightchild = minnumber2;</span><br><span class="line">		tree[minnumber1].parent = i;</span><br><span class="line">		tree[minnumber2].parent = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">codehafuman</span><span class="params">(HuffmanTree&amp; tree)</span> </span>&#123;<span class="comment">// 进行哈夫曼编码</span></span><br><span class="line">	<span class="type">int</span> stroenumber = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> app : dataweight) &#123;</span><br><span class="line">		<span class="type">char</span> datachar = app.first;</span><br><span class="line">		string codedata = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="type">int</span> current = stroenumber;</span><br><span class="line">		<span class="type">int</span> parent = tree[current].parent;</span><br><span class="line">		<span class="keyword">while</span> (parent != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tree[parent].leftchild == current) &#123;<span class="comment">// 判断这个节点是不是在这个树的左子树</span></span><br><span class="line">				codedata = <span class="string">&quot;0&quot;</span> + codedata;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;<span class="comment">// 如果不是在左子树,那么就是在右子树了</span></span><br><span class="line">				codedata = <span class="string">&quot;1&quot;</span> + codedata;</span><br><span class="line">			&#125;</span><br><span class="line">			current = parent;</span><br><span class="line">			parent = tree[current].parent;</span><br><span class="line">		&#125;</span><br><span class="line">		datacode[datachar] = codedata;</span><br><span class="line">		stroenumber++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">encoding</span><span class="params">(string stargeinformation)</span> </span>&#123;<span class="comment">// 对文章进行编码</span></span><br><span class="line">	string codedata = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> app : stargeinformation) &#123;</span><br><span class="line">		codedata += datacode[app];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> codedata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">skillcodehafuman</span><span class="params">(string&amp; codedata,HuffmanTree&amp;tree)</span> </span>&#123;<span class="comment">// 对哈夫曼编码进行解码</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> app : datacode) &#123;<span class="comment">// 对原来的马匹进行翻转成为一个新的map</span></span><br><span class="line">		codedatainformation[app.second] = app.first;</span><br><span class="line">	&#125;</span><br><span class="line">	string stringdata = <span class="string">&quot;&quot;</span>;<span class="comment">// 用来存储最后解码的字符</span></span><br><span class="line">	string datanumber = <span class="string">&quot;&quot;</span>;<span class="comment">// 用来存储二进制数据,到后面可以通过map来实现stringdata的直接拼接</span></span><br><span class="line">	<span class="type">int</span> number = dataweight.<span class="built_in">size</span>() * <span class="number">2</span> - <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : codedata) &#123;</span><br><span class="line">		<span class="keyword">if</span> (it == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			number = tree[number].leftchild;</span><br><span class="line">			datanumber += it;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			number = tree[number].rightchild;</span><br><span class="line">			datanumber += it;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tree[number].leftchild == <span class="number">-1</span> &amp;&amp; tree[number].rightchild == <span class="number">-1</span>) &#123;</span><br><span class="line">			stringdata += codedatainformation[datanumber];</span><br><span class="line">			number = dataweight.<span class="built_in">size</span>() * <span class="number">2</span> - <span class="number">2</span>;</span><br><span class="line">			datanumber = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> stringdata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入文章内容:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string line;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">getline</span>(cin, line);  <span class="comment">// 获取一行输入</span></span><br><span class="line">		<span class="keyword">if</span> (line.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">break</span>;  <span class="comment">// 输入空行时结束</span></span><br><span class="line">		&#125;</span><br><span class="line">		stargeinformation += line + <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 将每一行文本添加到 stargeinformation 中，并加上换行符</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getweight</span>(stargeinformation);<span class="comment">//获取文章中的数据的权重</span></span><br><span class="line">	HuffmanTree tree = <span class="built_in">CreateHuffmanTree</span>(dataweight.<span class="built_in">size</span>());<span class="comment">// 构造哈夫曼树</span></span><br><span class="line">	<span class="built_in">codehafuman</span>(tree);</span><br><span class="line">	string codedata = <span class="built_in">encoding</span>(stargeinformation);</span><br><span class="line">	cout &lt;&lt; codedata &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	string relute = <span class="built_in">skillcodehafuman</span>(codedata, tree);</span><br><span class="line">	cout &lt;&lt; relute &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">free</span>(tree);<span class="comment">// 释放空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-参考数据"><a href="#2-参考数据" class="headerlink" title="2.参考数据:"></a>2.参考数据:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Chinese official said he viewed the Trump Presidency not as an  aberration but as the product of a failing political system. This jibes with other  accounts. The Chinese leadership believes that the United States, and Western  democracies in general, haven’t risen to the challenge of a globalized economy,  which necessitates big changes in production patterns, as well as major upgrades  in education and public infrastructure. In Trump and Trumpism, the Chinese see  an inevitable backlash to this failure.</span><br></pre></td></tr></table></figure>

<h5 id="3-参考结果"><a href="#3-参考结果" class="headerlink" title="3.参考结果:"></a>3.参考结果:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入文章内容:</span><br><span class="line">The Chinese official said he viewed the Trump Presidency not as an  aberration but as the product of a failing political system. This jibes with other  accounts. The Chinese leadership believes that the United States, and Western  democracies in general, haven’t risen to the challenge of a globalized economy,  which necessitates big changes in production patterns, as well as major upgrades  in education and public infrastructure. In Trump and Trumpism, the Chinese see  an inevitable backlash to this failure.</span><br><span class="line"></span><br><span class="line">000011000100111101001000001110001100010111001111110100100110100111100101011100101110011111011110111100010101110001001111100100111000011001010001010101111000000100111100001111011010000101110000011110100001011011001011111000101000101101010101001011110110110101000111101101111111011011011111110111010010011101111011101110001100110100110111101001010001000111101101111111000000100111100000110111101001010010001010110001111101001001111110111110100111011110010011110001100101101110000011010100111100100011001010110111001111101110100101011110000010101111001000111000011000111000111111100101101100101001001011111110010101100100000011111101010000001001110111111111011101011010111010010000110100001111001000111000011000100111101001000001110001100010111001111100110011011010100011101101110001110000000111101001001100111100001100100100101111111000000110111000111100000010011111010001000110110010000010101011110100001110001011100000101110000101111011011001010111101000101001011110000011101101101111110101000101011111010101011101110111010111000010111111110001101110101100010110001110111011100110000101110001101110010010010110100101110100101111100011111011110001110010110111100011010111100000010011111010100011011100111001100101100101100011111101001001111110111110101101001111010101001101110011110010100011100101010111001101011101001101101001011101001010000101111111001010000111001010100011110110001101010010111011111001000101110000010111111101001110001011011110101000110110110010110001011111111000110111000001101111010010100100010101100011001101001101110000010111000100000111011011001110000101111011011111110010100011001110011111101101111110101111011100101101101011011111010000000001011011011101101010001011111111111000110111001010100100010101101110001100110100110111101101100101011100000010001010011001111001010111111000110010011110111011011110001101101000101011000010001101100110010001111010000010110111000011110110100001011100000111101101100101011100001111011010000101110000011000111010111000010111100000010011110100100000111000110001011100111101110010011111111011011011111000110001100100111001000101110100110011001111101001101110101101000110100111011011100011111000110101111000000111000111111010011101111001001101000110110011001000101000000</span><br><span class="line"></span><br><span class="line">The Chinese official said he viewed the Trump Presidency not as an  aberration but as the product of a failing political system. This jibes with other  accounts. The Chinese leadership believes that the United States, and Western  democracies in general, haven’t risen to the challenge of a globalized economy,  which necessitates big changes in production patterns, as well as major upgrades  in education and public infrastructure. In Trump and Trumpism, the Chinese see  an inevitable backlash to this failure.</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://8023time.github.io">寻觅~流光</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://8023time.github.io/2024/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%BA%8C/">https://8023time.github.io/2024/11/25/数据结构-实验二/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://8023time.github.io" target="_blank">寻觅~流光</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/C-C/">C/C++</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/basic-img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/basic-img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2024/11/26/%E5%8A%A8%E6%80%81%E7%88%B1%E5%BF%83/" title="动态爱心♥"><img class="cover" src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Interesting-webpage-image/20241126170116.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">动态爱心♥</div></div></a><a class="next-post pull-right" href="/2024/11/25/%E6%B0%B4%E5%A2%A8%E7%94%BB%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/" title="水墨画网页"><img class="cover" src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Interesting-webpage-image/20241126095152.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">水墨画网页</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2024/11/20/%E6%89%8B%E6%92%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%9F%E5%88%97,%E4%BB%A5%E5%AE%9E%E7%8E%B0BFS%E7%AE%97%E6%B3%95,%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%8E%9F%E6%9C%89%E7%9A%84queue/" title="数据结构queue实现BFS"><img class="cover" src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="title">数据结构queue实现BFS</div></div></a><a href="/2024/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%B8%80/" title="数据结构-实验一"><img class="cover" src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-22</div><div class="title">数据结构-实验一</div></div></a><a href="/2024/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8413-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构13-平衡二叉树"><img class="cover" src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-30</div><div class="title">数据结构13-平衡二叉树</div></div></a><a href="/2024/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%8010-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/" title="数据结构基础10-二叉树的创建与三种遍历"><img class="cover" src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-27</div><div class="title">数据结构基础10-二叉树的创建与三种遍历</div></div></a><a href="/2024/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8412-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/" title="数据结构12-二叉排序树"><img class="cover" src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-29</div><div class="title">数据结构12-二叉排序树</div></div></a><a href="/2024/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%8011-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E5%86%99%E6%B3%95/" title="数据结构基础11-线索二叉树的三种写法"><img class="cover" src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-28</div><div class="title">数据结构基础11-线索二叉树的三种写法</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/basic-img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">寻觅~流光</div><div class="author-info-description">在广州上学中~</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/8023time"><i class="fab fa-github"></i><span>我的GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><div style="text-align:center;">云雾依稀折柳枝,<br>凭栏更待青云月.<br>请君莫辞凌烟走,<br>惟愿神秀尽前时.</div><div style="text-align:right;">-----2023年6月8日</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%BA%8C"><span class="toc-number">1.</span> <span class="toc-text">数据结构-实验二</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">二叉树的操作与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">1、二叉树的基本操作算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%84%E7%A7%8D%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、二叉树的各种遍历算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%85%88%E5%BA%8F-%E4%B8%AD%E5%BA%8F%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.2.0.1.</span> <span class="toc-text">1.先序,中序的非递归遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.0.2.</span> <span class="toc-text">2.后序遍历的非递归的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">3、线索二叉树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91HT%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81HC%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E8%AF%91%E7%A0%81%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E3%80%82"><span class="toc-number">1.1.4.</span> <span class="toc-text">4、构造哈夫曼树HT、哈夫曼编码HC、哈夫曼译码的算法实现。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.4.0.1.</span> <span class="toc-text">2.参考数据:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8F%82%E8%80%83%E7%BB%93%E6%9E%9C"><span class="toc-number">1.1.4.0.2.</span> <span class="toc-text">3.参考结果:</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/Map(C++)/" title="Map"><img src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/C/C++-image/74b8bdb2ef6f685e13ca6d5921cf4ab.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Map"/></a><div class="content"><a class="title" href="/2024/12/07/Map(C++)/" title="Map">Map</a><time datetime="2024-12-06T16:00:00.000Z" title="发表于 2024-12-07 00:00:00">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/" title="分块查找"><img src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/C/C++-image/74b8bdb2ef6f685e13ca6d5921cf4ab.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分块查找"/></a><div class="content"><a class="title" href="/2024/12/07/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/" title="分块查找">分块查找</a><time datetime="2024-12-06T16:00:00.000Z" title="发表于 2024-12-07 00:00:00">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/" title="排序二叉树"><img src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/C/C++-image/74b8bdb2ef6f685e13ca6d5921cf4ab.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="排序二叉树"/></a><div class="content"><a class="title" href="/2024/12/07/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/" title="排序二叉树">排序二叉树</a><time datetime="2024-12-06T16:00:00.000Z" title="发表于 2024-12-07 00:00:00">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/01/JavaScript%E5%B8%B8%E7%94%A8%E5%B0%8F%E7%9F%A5%E8%AF%86/" title="JavaScript常用小知识"><img src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/JavaScript-image/JavaScript%E5%9B%BE%E7%89%87.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript常用小知识"/></a><div class="content"><a class="title" href="/2024/12/01/JavaScript%E5%B8%B8%E7%94%A8%E5%B0%8F%E7%9F%A5%E8%AF%86/" title="JavaScript常用小知识">JavaScript常用小知识</a><time datetime="2024-11-30T16:00:00.000Z" title="发表于 2024-12-01 00:00:00">2024-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/01/Map/" title="Map"><img src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/JavaScript-image/JavaScript%E5%9B%BE%E7%89%87.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Map"/></a><div class="content"><a class="title" href="/2024/12/01/Map/" title="Map">Map</a><time datetime="2024-11-30T16:00:00.000Z" title="发表于 2024-12-01 00:00:00">2024-12-01</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2024 By 寻觅~流光</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":false},"log":false});</script></body></html>