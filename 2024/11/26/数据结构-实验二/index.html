<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>数据结构-实验二 | 寻觅~流光</title><meta name="author" content="寻觅~流光"><meta name="copyright" content="寻觅~流光"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构-实验二二叉树的操作与实现1、二叉树的基本操作算法实现 (1) 利用(广义表)二叉树字符串“A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))”创建二叉树 的二叉链式存储结构；(请勿根据扩展二叉树进行创建)   (2) 输出该二叉树(中序遍历序列)；   (3) 输出‘H’结点的左、右孩子结点值；   (4) 输出该二叉树的结点个数、叶子结点个数、二叉树的度和高度。"><meta property="og:type" content="article"><meta property="og:title" content="数据结构-实验二"><meta property="og:url" content="https://8023time.github.io/2024/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%BA%8C/index.html"><meta property="og:site_name" content="寻觅~流光"><meta property="og:description" content="数据结构-实验二二叉树的操作与实现1、二叉树的基本操作算法实现 (1) 利用(广义表)二叉树字符串“A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))”创建二叉树 的二叉链式存储结构；(请勿根据扩展二叉树进行创建)   (2) 输出该二叉树(中序遍历序列)；   (3) 输出‘H’结点的左、右孩子结点值；   (4) 输出该二叉树的结点个数、叶子结点个数、二叉树的度和高度。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png"><meta property="article:published_time" content="2024-11-25T16:00:00.000Z"><meta property="article:modified_time" content="2024-12-14T11:57:45.165Z"><meta property="article:author" content="寻觅~流光"><meta property="article:tag" content="C&#x2F;C++"><meta property="article:tag" content="数据结构"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/basic-img/avatar.jpg"><link rel="canonical" href="https://8023time.github.io/2024/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%BA%8C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{let t={set:(e,t,a)=>{a&&(a=Date.now()+864e5*a,localStorage.setItem(e,JSON.stringify({value:t,expiry:a})))},get:e=>{var t=localStorage.getItem(e);if(t){var{value:t,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return t;localStorage.removeItem(e)}}},a=(window.btf={saveToLocal:t,getScript:(o,r={})=>new Promise((e,t)=>{let a=document.createElement("script");a.src=o,a.async=!0,Object.entries(r).forEach(([e,t])=>a.setAttribute(e,t)),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),getCSS:(o,r)=>new Promise((e,t)=>{let a=document.createElement("link");a.rel="stylesheet",a.href=o,r&&(a.id=r),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),addGlobalFn:(e,t,a=!1,o=window)=>{var r;e.startsWith("pjax")||((r=o.globalFn||{})[e]=r[e]||{},a&&r[e][a])||(r[e][a||Object.keys(r[e]).length]=t,o.globalFn=r)}},()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")}),o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=a,btf.activateLightMode=o;var r=t.get("theme"),n=window.matchMedia("(prefers-color-scheme: dark)"),d=window.matchMedia("(prefers-color-scheme: light)"),d=(void 0===r?((!d.matches&&(n.matches||(d=(new Date).getHours())<=8||21<=d)?a:o)(),n.addEventListener("change",()=>{void 0===t.get("theme")&&(e.matches?a:o)()})):("light"===r?o:a)(),t.get("aside-status"));void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>let GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"数据结构-实验二",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-12-14 19:57:45"}</script><link rel="stylesheet" href="/css/universe.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{let e=document.getElementById("loading-box"),d=document.body;const o=()=>{d.style.overflow="",e.classList.add("loaded")},l=()=>{d.style.overflow="hidden",e.classList.remove("loaded")};l(),window.addEventListener("load",o)})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/basic-img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友联</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/basic-img/avatar.jpg" alt="Logo"><span class="site-name">寻觅~流光</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构-实验二</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友联</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构-实验二</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-11-25T16:00:00.000Z" title="发表于 2024-11-26 00:00:00">2024-11-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构-实验二"><a href="#数据结构-实验二" class="headerlink" title="数据结构-实验二"></a>数据结构-实验二</h1><h2 id="二叉树的操作与实现"><a href="#二叉树的操作与实现" class="headerlink" title="二叉树的操作与实现"></a>二叉树的操作与实现</h2><h3 id="1、二叉树的基本操作算法实现"><a href="#1、二叉树的基本操作算法实现" class="headerlink" title="1、二叉树的基本操作算法实现"></a>1、二叉树的基本操作算法实现</h3><blockquote><p>(1) 利用(广义表)二叉树字符串“A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))”创建二叉树 的二叉链式存储结构；(请勿根据扩展二叉树进行创建)</p><p>(2) 输出该二叉树(中序遍历序列)；</p><p>(3) 输出‘H’结点的左、右孩子结点值；</p><p>(4) 输出该二叉树的结点个数、叶子结点个数、二叉树的度和高度。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;<span class="comment">// 定义一个二叉树</span></span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Tree</span>* leftchild, * rightchild;</span><br><span class="line">&#125;tree,*treenode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Stack</span> &#123;<span class="comment">// 定义一个栈</span></span><br><span class="line">	tree* data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Stack</span>* next;</span><br><span class="line">&#125;stack,*stacknode;</span><br><span class="line"></span><br><span class="line"><span class="function">stacknode <span class="title">createstack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	stacknode root = <span class="keyword">new</span> stack;</span><br><span class="line">	root-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">	root-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addstack</span><span class="params">(stacknode root, tree* data)</span> </span>&#123;</span><br><span class="line">	stack* node = <span class="keyword">new</span> stack;</span><br><span class="line">	node-&gt;data = data;</span><br><span class="line">	node-&gt;next = root-&gt;next;</span><br><span class="line">	root-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">tree* <span class="title">popstack</span><span class="params">(stacknode&amp; root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		stack* node = root-&gt;next;</span><br><span class="line">		root-&gt;next = node-&gt;next;</span><br><span class="line">		tree* data = node-&gt;data;</span><br><span class="line">		<span class="keyword">delete</span> node;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">tree* <span class="title">topstack</span><span class="params">(stacknode&amp; root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		stack* node = root-&gt;next;</span><br><span class="line">		<span class="keyword">return</span> node-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">(stacknode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTree</span><span class="params">(treenode &amp;root,string&amp; stringdata)</span> </span>&#123;<span class="comment">// 创建二叉树</span></span><br><span class="line">	stacknode stackroot = <span class="built_in">createstack</span>();</span><br><span class="line">	tree* current = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> isleft = <span class="literal">true</span>;<span class="comment">// 在这里判断,如果是true,就把新的节点加到左子树上去,如果是false的话,就把这个加到右子树上去</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">char</span> it : stringdata) &#123;<span class="comment">// 如果是(的话,就是(前面的入栈,(后面的作为其左子树,&quot;,&quot;后面的就作为他的右子树</span></span><br><span class="line">		<span class="keyword">if</span> (it == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">			<span class="built_in">addstack</span>(stackroot, current);</span><br><span class="line">			isleft = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (it == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">			<span class="built_in">popstack</span>(stackroot);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (it == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">			isleft = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			treenode node = <span class="keyword">new</span> tree;</span><br><span class="line">			node-&gt;data = it;</span><br><span class="line">			node-&gt;leftchild = <span class="literal">NULL</span>;</span><br><span class="line">			node-&gt;rightchild = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">empty</span>(stackroot)) &#123;</span><br><span class="line">				root = node;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				tree* parent = <span class="built_in">topstack</span>(stackroot);</span><br><span class="line">				<span class="keyword">if</span> (isleft) &#123;</span><br><span class="line">					parent-&gt;leftchild = node;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					parent-&gt;rightchild = node;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			current = node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(treenode&amp; root)</span> </span>&#123;<span class="comment">// 中序遍历</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">inorder</span>(root-&gt;leftchild);</span><br><span class="line">		cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot;---&quot;</span>;</span><br><span class="line">		<span class="built_in">inorder</span>(root-&gt;rightchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">returnlength</span><span class="params">(treenode root)</span> </span>&#123; <span class="comment">// 返回二叉树的高度</span></span><br><span class="line">	<span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="built_in">max</span>(<span class="built_in">returnlength</span>(root-&gt;leftchild),<span class="built_in">returnlength</span>(root-&gt;rightchild)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">returngeshu</span><span class="params">(treenode root)</span> </span>&#123; <span class="comment">// 返回二叉树节点的个数</span></span><br><span class="line">	<span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="built_in">returngeshu</span>(root-&gt;leftchild) + <span class="built_in">returngeshu</span>(root-&gt;rightchild) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">returnyezishu</span><span class="params">(treenode root)</span> </span>&#123; <span class="comment">// 返回叶子数目</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;leftchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rightchild == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">returnyezishu</span>(root-&gt;leftchild) + <span class="built_in">returnyezishu</span>(root-&gt;rightchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printChildren</span><span class="params">(treenode root, <span class="type">char</span> target)</span> </span>&#123;<span class="comment">// 输出任意结点的左右孩子结点值</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;data == target) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;结点 &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; 的孩子: &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;leftchild) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;左孩子: &quot;</span> &lt;&lt; root-&gt;leftchild-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;左孩子: NULL &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;rightchild) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;右孩子: &quot;</span> &lt;&lt; root-&gt;rightchild-&gt;data &lt;&lt; endl;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;右孩子: NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printChildren</span>(root-&gt;leftchild, target);</span><br><span class="line">	<span class="built_in">printChildren</span>(root-&gt;rightchild, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDegree</span><span class="params">(treenode root)</span> </span>&#123;<span class="comment">// 二叉树的度  // 直接利用上面的那两个叶子节点和总的节点来求</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">returngeshu</span>(root) - <span class="built_in">returnyezishu</span>(root)) * <span class="number">2</span> + <span class="built_in">returnyezishu</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入二叉树的广义表的表示形式:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string stringdata;</span><br><span class="line">	cin &gt;&gt; stringdata;</span><br><span class="line">	treenode root;</span><br><span class="line">	<span class="built_in">createTree</span>(root, stringdata);</span><br><span class="line">	<span class="built_in">inorder</span>(root);<span class="comment">// 中序遍历二叉树</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入任意结点,我会返回他的的左、右孩子结点值&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">char</span> target;</span><br><span class="line">	cin &gt;&gt; target;</span><br><span class="line">	<span class="built_in">printChildren</span>(root, target);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;这个二叉树的节点个数为:&quot;</span> &lt;&lt; <span class="built_in">returngeshu</span>(root) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;这个二叉树的叶子节点个数为:&quot;</span> &lt;&lt; <span class="built_in">returnyezishu</span>(root) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;这个二叉树的高度为:&quot;</span> &lt;&lt; <span class="built_in">returnlength</span>(root) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;这个二叉树的度为:&quot;</span> &lt;&lt; <span class="built_in">maxDegree</span>(root) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-参考数据"><a href="#2-参考数据" class="headerlink" title="2.参考数据:"></a>2.参考数据:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))</span><br></pre></td></tr></table></figure><h5 id="3-参考结果"><a href="#3-参考结果" class="headerlink" title="3.参考结果:"></a>3.参考结果:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">请输入二叉树的广义表的表示形式:</span><br><span class="line"><span class="built_in">A</span>(<span class="built_in">B</span>(D,<span class="built_in">E</span>(<span class="built_in">H</span>(J,<span class="built_in">K</span>(L,<span class="built_in">M</span>(,N))))),<span class="built_in">C</span>(F,<span class="built_in">G</span>(,I)))</span><br><span class="line">D---B---J---H---L---K---M---N---E---A---F---C---G---I---输入任意结点,我会返回他的的左、右孩子结点值</span><br><span class="line">N</span><br><span class="line">结点 N 的孩子: 左孩子: <span class="literal">NULL</span> 右孩子: <span class="literal">NULL</span></span><br><span class="line">这个二叉树的节点个数为:<span class="number">14</span></span><br><span class="line">这个二叉树的叶子节点个数为:<span class="number">6</span></span><br><span class="line">这个二叉树的高度为:<span class="number">7</span></span><br><span class="line">这个二叉树的度为:<span class="number">22</span></span><br></pre></td></tr></table></figure><h3 id="2、二叉树的各种遍历算法实现"><a href="#2、二叉树的各种遍历算法实现" class="headerlink" title="2、二叉树的各种遍历算法实现"></a>2、二叉树的各种遍历算法实现</h3><blockquote><p>实现上述二叉树的先序、中序和后序遍历的递归和非递归算法。</p></blockquote><h5 id="1-先序-中序的非递归遍历"><a href="#1-先序-中序的非递归遍历" class="headerlink" title="1.先序,中序的非递归遍历"></a>1.先序,中序的非递归遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;<span class="comment">// 数据</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Tree</span>* leftchild;<span class="comment">// 左子树</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Tree</span>* rightchild;<span class="comment">// 右子树</span></span><br><span class="line">&#125;tree, * treelist;</span><br><span class="line"><span class="comment">// 栈的创建</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stacknode</span> &#123;</span><br><span class="line">	tree* data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stacknode</span>* next;</span><br><span class="line">&#125;node, * stack;</span><br><span class="line"><span class="comment">// 二叉树的创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTree</span><span class="params">(treelist&amp; app)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">		app = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		app = <span class="keyword">new</span> Tree;</span><br><span class="line">		app-&gt;data = ch;</span><br><span class="line">		<span class="built_in">createTree</span>(app-&gt;leftchild);</span><br><span class="line">		<span class="built_in">createTree</span>(app-&gt;rightchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initstack</span><span class="params">(stack root)</span> </span>&#123;</span><br><span class="line">	root-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">	root-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在栈中加入一些数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushstack</span><span class="params">(stack root, tree* app)</span> </span>&#123;</span><br><span class="line">	node* stackapp = (node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">	stackapp-&gt;data = app;</span><br><span class="line">	stackapp-&gt;next = root-&gt;next;</span><br><span class="line">	root-&gt;next = stackapp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">(stack root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将栈中的数据拿出来</span></span><br><span class="line"><span class="function">node* <span class="title">popstack</span><span class="params">(stack root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isempty</span>(root)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		node* app = root-&gt;next;</span><br><span class="line">		root-&gt;next = app-&gt;next;</span><br><span class="line">		<span class="keyword">return</span> app;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="comment">// 基本思想很简单</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(treelist app)</span> </span>&#123;</span><br><span class="line">	treelist APP = app;</span><br><span class="line">	stack stackAPP = <span class="keyword">new</span> node;</span><br><span class="line">	<span class="built_in">initstack</span>(stackAPP);</span><br><span class="line">	<span class="keyword">while</span> (APP || !<span class="built_in">isempty</span>(stackAPP)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (APP) &#123;</span><br><span class="line">			cout &lt;&lt; APP-&gt;data &lt;&lt; <span class="string">&quot;---&quot;</span>;</span><br><span class="line">			<span class="built_in">pushstack</span>(stackAPP, APP);</span><br><span class="line">			APP = APP-&gt;leftchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			APP = <span class="built_in">popstack</span>(stackAPP)-&gt;data;</span><br><span class="line">			APP = APP-&gt;rightchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="comment">// 基本思想就是到左子树遍历到null的时候就出栈,打印出数据,只要为空就打印出栈中的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(treelist app)</span> </span>&#123;</span><br><span class="line">	treelist APP = app;</span><br><span class="line">	stack stackAPP = <span class="keyword">new</span> node;</span><br><span class="line">	<span class="built_in">initstack</span>(stackAPP);</span><br><span class="line">	<span class="keyword">while</span> (APP || !<span class="built_in">isempty</span>(stackAPP)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (APP) &#123;</span><br><span class="line">			<span class="built_in">pushstack</span>(stackAPP, APP);</span><br><span class="line">			APP = APP-&gt;leftchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			APP = <span class="built_in">popstack</span>(stackAPP)-&gt;data;</span><br><span class="line">			cout &lt;&lt; APP-&gt;data &lt;&lt; <span class="string">&quot;---&quot;</span>;</span><br><span class="line">			APP = APP-&gt;rightchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	treelist app;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入二叉树的数据&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">createTree</span>(app);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;先序遍历:&quot;</span>;</span><br><span class="line">	<span class="built_in">preorder</span>(app);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;中序遍历:&quot;</span>;</span><br><span class="line">	<span class="built_in">inorder</span>(app);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>就是借用了栈的用法,先序遍历就是先把左边的输出出来,同时伴随着入栈操作,到后面左子树为空的时候就出栈搞右子树的内容输出出来,右子树空了就再出栈…….;</p><p>中序遍历: 基本思想就是到左子树遍历到null的时候就出栈,打印出数据,只要为空就打印出栈中的数据</p></blockquote><h5 id="2-后序遍历的非递归的方法"><a href="#2-后序遍历的非递归的方法" class="headerlink" title="2.后序遍历的非递归的方法"></a>2.后序遍历的非递归的方法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tree</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tree</span>* lefttree, * righttree;</span><br><span class="line">	<span class="type">bool</span> flage;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义一个栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stack</span> &#123;</span><br><span class="line">	tree* data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stack</span>* next;</span><br><span class="line">&#125;*stacknode;</span><br><span class="line"><span class="comment">// 创建一个二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createtree</span><span class="params">(tree*&amp; app)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	cin &gt;&gt; data;</span><br><span class="line">	<span class="keyword">if</span> (data == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">		app = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		app = <span class="keyword">new</span> tree;</span><br><span class="line">		app -&gt; data = data;</span><br><span class="line">		app-&gt;flage = <span class="literal">false</span>;</span><br><span class="line">		<span class="built_in">createtree</span>(app-&gt;lefttree);</span><br><span class="line">		<span class="built_in">createtree</span>(app-&gt;righttree);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化一个栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initstack</span><span class="params">(stacknode &amp;app)</span> </span>&#123;</span><br><span class="line">	app-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">	app-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给栈加入一个数据到栈里面去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addstack</span><span class="params">(stacknode&amp; app, tree* data)</span> </span>&#123;</span><br><span class="line">	stacknode node = <span class="keyword">new</span> stack;</span><br><span class="line">	node-&gt;data = data;</span><br><span class="line">	node-&gt;next = app-&gt;next;</span><br><span class="line">	app-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 栈弹出来一个元素</span></span><br><span class="line"><span class="function">tree* <span class="title">popstack</span><span class="params">(stacknode&amp; app)</span> </span>&#123;</span><br><span class="line">	tree* data = app-&gt;next-&gt;data;</span><br><span class="line">	stacknode number = app-&gt;next;</span><br><span class="line">	app-&gt;next = number-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> number;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查看栈头顶的那个元素</span></span><br><span class="line"><span class="function">tree* <span class="title">checkstack</span><span class="params">(stacknode&amp; app)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> app-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">(stacknode&amp; app)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (app-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线索化二叉树	</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(tree* app)</span> </span>&#123;</span><br><span class="line">	tree* APP = app;</span><br><span class="line">	stacknode stackdata = <span class="keyword">new</span> stack;</span><br><span class="line">	<span class="built_in">initstack</span>(stackdata);</span><br><span class="line">		<span class="keyword">while</span> (APP || !<span class="built_in">isempty</span>(stackdata)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (APP) &#123;</span><br><span class="line">				<span class="built_in">addstack</span>(stackdata, APP);</span><br><span class="line">				APP = APP-&gt;lefttree;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				tree* top = <span class="built_in">checkstack</span>(stackdata);</span><br><span class="line">				<span class="keyword">if</span> (top-&gt;righttree &amp;&amp; top-&gt;righttree-&gt;flage == <span class="literal">false</span>) &#123;<span class="comment">// 判断右节点是否被访问过,没有的户就把这个右节点存储到栈中</span></span><br><span class="line">					top = top-&gt;righttree;</span><br><span class="line">					<span class="built_in">addstack</span>(stackdata, top);</span><br><span class="line">					APP = top-&gt;lefttree;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					tree* topdata = <span class="built_in">popstack</span>(stackdata);</span><br><span class="line">					cout &lt;&lt; topdata-&gt;data &lt;&lt; <span class="string">&quot;---&quot;</span>;</span><br><span class="line">					topdata-&gt;flage = <span class="literal">true</span>;<span class="comment">// 标记这个节点已经被访问过,后面不用再次访问这个节点了</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	tree* app;</span><br><span class="line">	<span class="built_in">createtree</span>(app);<span class="comment">//创建一个二叉树</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;后序遍历二叉树采用非递归的方法:&quot;</span>;</span><br><span class="line">	<span class="built_in">postorder</span>(app);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里与上面的两个遍历有一点不一样,这个借助了一个flag来判断右子树有没有被访问过,如果没有就入栈,直到为NULL的时候出栈;如果右子树被访问过,那么就是不入栈……,依此不断重复…</p></blockquote><h3 id="3、线索二叉树的遍历"><a href="#3、线索二叉树的遍历" class="headerlink" title="3、线索二叉树的遍历"></a>3、线索二叉树的遍历</h3><blockquote><p>中序线索化上述二叉树并找出根结点的前驱和后继。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiThrNode</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;<span class="comment">// 数据</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiThrNode</span>* leftchild;<span class="comment">// 左指针</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiThrNode</span>* rightchild;<span class="comment">// 右指针</span></span><br><span class="line">	<span class="type">int</span> LTag; <span class="comment">// 左标志</span></span><br><span class="line">	<span class="type">int</span> RTag; <span class="comment">// 右标志</span></span><br><span class="line">&#125;BiThrNode, * BiThrTree;</span><br><span class="line"><span class="comment">// 全局定义一个线索化二叉树的一个全局变量</span></span><br><span class="line">BiThrNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 二叉树的创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTree</span><span class="params">(BiThrTree&amp; app)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">		app = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		app = <span class="keyword">new</span> BiThrNode;</span><br><span class="line">		app-&gt;data = ch;</span><br><span class="line">		app-&gt;LTag = <span class="number">0</span>;</span><br><span class="line">		app-&gt;RTag = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">createTree</span>(app-&gt;leftchild);</span><br><span class="line">		<span class="built_in">createTree</span>(app-&gt;rightchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线索化中序二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">middleTree</span><span class="params">(BiThrTree &amp;app)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (app) &#123;</span><br><span class="line">		<span class="built_in">middleTree</span>(app-&gt;leftchild);</span><br><span class="line">		<span class="comment">// 在这里写一些线索化的代码</span></span><br><span class="line">		<span class="keyword">if</span> (!app-&gt;leftchild) &#123;<span class="comment">// 如果左子树为空,线索化左子树</span></span><br><span class="line">			app-&gt;LTag = <span class="number">1</span>;</span><br><span class="line">			app-&gt;leftchild = pre;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rightchild == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果pre的右子树为空的话,线索化最下面的这个节点前驱后继之类</span></span><br><span class="line">			pre-&gt;RTag = <span class="number">1</span>;</span><br><span class="line">			pre-&gt;rightchild = app;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = app;</span><br><span class="line">		<span class="built_in">middleTree</span>(app-&gt;rightchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面就是遍历线索化中序二叉树的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">middleprintf</span><span class="params">(BiThrTree&amp; app)</span> </span>&#123;</span><br><span class="line">	BiThrNode* current = app;</span><br><span class="line">	<span class="keyword">while</span> (current &amp;&amp; current-&gt;LTag == <span class="number">0</span>) &#123;</span><br><span class="line">		current = current-&gt;leftchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (current) &#123;</span><br><span class="line">		cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot;---&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;RTag == <span class="number">1</span>) &#123;</span><br><span class="line">			current = current-&gt;rightchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			current = current-&gt;rightchild;</span><br><span class="line">			<span class="keyword">while</span> (current &amp;&amp; current-&gt;LTag == <span class="number">0</span>) &#123;</span><br><span class="line">				current = current-&gt;leftchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BiThrTree app;</span><br><span class="line">	<span class="built_in">createTree</span>(app);</span><br><span class="line">	<span class="built_in">middleTree</span>(app);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线索化中序二叉树的遍历为:&quot;</span>;</span><br><span class="line">	<span class="built_in">middleprintf</span>(app);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在这里的话就是使用递归的操作,加上了使用rTag与lTag两个标志,为0的时候表示的是左右子树,为1的时候就是表示有前驱或者后继,如果遍历到一个子树没有左子树的时候就指向他的前驱,右子树同理:指向后继……….;</p><p>线索化这个二叉树相当于就是重新对这个二叉树进行一个遍历以及对他的是否指向前驱或者后继还是左右子树进行一个修饰的过程;后面就是遍历线索二叉树,易于理解</p></blockquote><h3 id="4、构造哈夫曼树HT、哈夫曼编码HC、哈夫曼译码的算法实现。"><a href="#4、构造哈夫曼树HT、哈夫曼编码HC、哈夫曼译码的算法实现。" class="headerlink" title="4、构造哈夫曼树HT、哈夫曼编码HC、哈夫曼译码的算法实现。"></a>4、构造哈夫曼树HT、哈夫曼编码HC、哈夫曼译码的算法实现。</h3><blockquote><p>在发送端，统计下面一段英文的不同字符个数和每个字符的出现频率，利用统 计数据构造构造哈夫曼树和哈夫曼编码；在接收端，将接收到的 0-1 序列恢复成英 文段落。</p><p>The Chinese official said he viewed the Trump Presidency not as an aberration but as the product of a failing political system. This jibes with other accounts. The Chinese leadership believes that the United States, and Western democracies in general, haven’t risen to the challenge of a globalized economy, which necessitates big changes in production patterns, as well as major upgrades in education and public infrastructure. In Trump and Trumpism, the Chinese see an inevitable backlash to this failure.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;dataweight;<span class="comment">// 存储权值的map容器</span></span><br><span class="line">map&lt;<span class="type">char</span>, string&gt;datacode;<span class="comment">// 存储01数据的</span></span><br><span class="line">map&lt;string, <span class="type">char</span>&gt;codedatainformation;<span class="comment">// 存储01对应的字符</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_size 9999</span></span><br><span class="line">string stargeinformation;<span class="comment">// 用来存储文章的内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">// 定义哈夫曼树</span></span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="type">int</span> parent;</span><br><span class="line">	<span class="type">int</span> leftchild;</span><br><span class="line">	<span class="type">int</span> rightchild;</span><br><span class="line">&#125;Huffmannode,*HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getweight</span><span class="params">(string&amp; app)</span> </span>&#123;<span class="comment">// 获取文章的各个字符的权重</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> spp : app) &#123;</span><br><span class="line">		dataweight[spp]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">CreateHuffmanTree</span><span class="params">(<span class="type">int</span> length)</span> </span>&#123;<span class="comment">// 创建一个哈夫曼树</span></span><br><span class="line">	<span class="type">int</span> totallength = length * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">	HuffmanTree tree = (HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Huffmannode) * (totallength));<span class="comment">// 首先要分配内存</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; totallength;i++) &#123;<span class="comment">//初始化所有的节点</span></span><br><span class="line">		tree[i].weight = <span class="number">0</span>;</span><br><span class="line">		tree[i].leftchild = <span class="number">-1</span>;</span><br><span class="line">		tree[i].rightchild = <span class="number">-1</span>;</span><br><span class="line">		tree[i].parent = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;<span class="comment">//前面的length个节点要进行填充操作</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : dataweight) &#123;</span><br><span class="line">		tree[index++].weight = it.second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = length;i &lt; totallength;i++) &#123;<span class="comment">// 接下来就是构造哈夫曼树</span></span><br><span class="line">		<span class="type">int</span> minnumber1 = <span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> minnumber2 = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tree[j].parent == <span class="number">-1</span>) &#123;<span class="comment">// 如果在这个哈夫曼书中找到了这个父节点没有的节点的话就通过</span></span><br><span class="line">				<span class="keyword">if</span> (minnumber1 == <span class="number">-1</span> || tree[minnumber1].weight &gt; tree[j].weight) &#123;<span class="comment">// 找到两个最小的节点</span></span><br><span class="line">					minnumber2 = minnumber1;</span><br><span class="line">					minnumber1 = j;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (minnumber2 == <span class="number">-1</span> || tree[minnumber2].weight &gt; tree[j].weight) &#123;</span><br><span class="line">					minnumber2 = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tree[i].weight = tree[minnumber1].weight + tree[minnumber2].weight;</span><br><span class="line">		tree[i].leftchild = minnumber1;</span><br><span class="line">		tree[i].rightchild = minnumber2;</span><br><span class="line">		tree[minnumber1].parent = i;</span><br><span class="line">		tree[minnumber2].parent = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">codehafuman</span><span class="params">(HuffmanTree&amp; tree)</span> </span>&#123;<span class="comment">// 进行哈夫曼编码</span></span><br><span class="line">	<span class="type">int</span> stroenumber = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> app : dataweight) &#123;</span><br><span class="line">		<span class="type">char</span> datachar = app.first;</span><br><span class="line">		string codedata = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="type">int</span> current = stroenumber;</span><br><span class="line">		<span class="type">int</span> parent = tree[current].parent;</span><br><span class="line">		<span class="keyword">while</span> (parent != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tree[parent].leftchild == current) &#123;<span class="comment">// 判断这个节点是不是在这个树的左子树</span></span><br><span class="line">				codedata = <span class="string">&quot;0&quot;</span> + codedata;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;<span class="comment">// 如果不是在左子树,那么就是在右子树了</span></span><br><span class="line">				codedata = <span class="string">&quot;1&quot;</span> + codedata;</span><br><span class="line">			&#125;</span><br><span class="line">			current = parent;</span><br><span class="line">			parent = tree[current].parent;</span><br><span class="line">		&#125;</span><br><span class="line">		datacode[datachar] = codedata;</span><br><span class="line">		stroenumber++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">encoding</span><span class="params">(string stargeinformation)</span> </span>&#123;<span class="comment">// 对文章进行编码</span></span><br><span class="line">	string codedata = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> app : stargeinformation) &#123;</span><br><span class="line">		codedata += datacode[app];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> codedata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">skillcodehafuman</span><span class="params">(string&amp; codedata,HuffmanTree&amp;tree)</span> </span>&#123;<span class="comment">// 对哈夫曼编码进行解码</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> app : datacode) &#123;<span class="comment">// 对原来的马匹进行翻转成为一个新的map</span></span><br><span class="line">		codedatainformation[app.second] = app.first;</span><br><span class="line">	&#125;</span><br><span class="line">	string stringdata = <span class="string">&quot;&quot;</span>;<span class="comment">// 用来存储最后解码的字符</span></span><br><span class="line">	string datanumber = <span class="string">&quot;&quot;</span>;<span class="comment">// 用来存储二进制数据,到后面可以通过map来实现stringdata的直接拼接</span></span><br><span class="line">	<span class="type">int</span> number = dataweight.<span class="built_in">size</span>() * <span class="number">2</span> - <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : codedata) &#123;</span><br><span class="line">		<span class="keyword">if</span> (it == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			number = tree[number].leftchild;</span><br><span class="line">			datanumber += it;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			number = tree[number].rightchild;</span><br><span class="line">			datanumber += it;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tree[number].leftchild == <span class="number">-1</span> &amp;&amp; tree[number].rightchild == <span class="number">-1</span>) &#123;</span><br><span class="line">			stringdata += codedatainformation[datanumber];</span><br><span class="line">			number = dataweight.<span class="built_in">size</span>() * <span class="number">2</span> - <span class="number">2</span>;</span><br><span class="line">			datanumber = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> stringdata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入文章内容:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string line;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">getline</span>(cin, line);  <span class="comment">// 获取一行输入</span></span><br><span class="line">		<span class="keyword">if</span> (line.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">break</span>;  <span class="comment">// 输入空行时结束</span></span><br><span class="line">		&#125;</span><br><span class="line">		stargeinformation += line + <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 将每一行文本添加到 stargeinformation 中，并加上换行符</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getweight</span>(stargeinformation);<span class="comment">//获取文章中的数据的权重</span></span><br><span class="line">	HuffmanTree tree = <span class="built_in">CreateHuffmanTree</span>(dataweight.<span class="built_in">size</span>());<span class="comment">// 构造哈夫曼树</span></span><br><span class="line">	<span class="built_in">codehafuman</span>(tree);</span><br><span class="line">	string codedata = <span class="built_in">encoding</span>(stargeinformation);</span><br><span class="line">	cout &lt;&lt; codedata &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	string relute = <span class="built_in">skillcodehafuman</span>(codedata, tree);</span><br><span class="line">	cout &lt;&lt; relute &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">free</span>(tree);<span class="comment">// 释放空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这次的构造哈夫曼树编码的实验代码中,我使用3个map容器辅助存储字符的权值大小,以及存储单个字符的二进制编码,还有一个是逆序存储了二进制编码对应的字符;</p><p>基本思路就是书上的思路:这里数组来存储哈夫曼树,刚开始使用map的键值对存储输入字符的出现次数,接着利用map容器自带的size()表示长度,也就是叶子节点个数(有效存储信息的节点),往后就是依次储存到数组里面去;</p><p>后面在长度为n,在区间(n-n-2)里面存储度为二的父亲节点中依顺序在前n个节点依次找到两个权值最小的两个节点作为那个父亲节点的两个孩儿,依次往复,直到没有;</p><p>接着就是编码,从叶子节点往上面去编码左子树为0,右子树为1,直到根节点(根节点的parent为-1,这个判断是不是根节点),保存二进制到map容器中,键为字符,值为二进制编码,直到把所有的n个节点搞完;</p><p>然后又是利用循环对刚开始输入的文章进行循环,通过map存储的二进制数据对每一个字符进行编码;</p><p>最后就是译码了,,,从根节点出发一直到叶子节点,左子树为0,右子树为1,判断结束条件就是叶子节点的没有左右子树节点(leftchild&#x3D;&#x3D;rightchile&#x3D;&#x3D;-1),这样把这个二进制存下来,又通过最前面我提到的第三个map容器,他的作用就体现出来了,键存储的是之前的二进制编码,值就是字符,通过如此循环,再通过字符串的拼接就能译码成功了,就能重新搞出来一个刚才一样的文章了(^_^)</p></blockquote><h5 id="2-参考数据-1"><a href="#2-参考数据-1" class="headerlink" title="2.参考数据:"></a>2.参考数据:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The Chinese official said he viewed the Trump Presidency not as an </span><br><span class="line">aberration but as the product of a failing political system. This jibes with other </span><br><span class="line">accounts. The Chinese leadership believes that the United States, and Western </span><br><span class="line">democracies in general, haven’t risen to the challenge of a globalized economy, </span><br><span class="line">which necessitates big changes in production patterns, as well as major upgrades </span><br><span class="line">in education and public infrastructure. In Trump and Trumpism, the Chinese see </span><br><span class="line">an inevitable backlash to this failure.</span><br></pre></td></tr></table></figure><h5 id="3-参考结果-1"><a href="#3-参考结果-1" class="headerlink" title="3.参考结果:"></a>3.参考结果:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">请输入文章内容:</span><br><span class="line">The Chinese official said he viewed the Trump Presidency not as an</span><br><span class="line">aberration but as the product of a failing political system. This jibes with other</span><br><span class="line">accounts. The Chinese leadership believes that the United States, and Western</span><br><span class="line">democracies in general, haven’t risen to the challenge of a globalized economy,</span><br><span class="line">which necessitates big changes in production patterns, as well as major upgrades</span><br><span class="line">in education and public infrastructure. In Trump and Trumpism, the Chinese see</span><br><span class="line">an inevitable backlash to this failure.</span><br><span class="line"></span><br><span class="line">000101000000111101000000000101101100010111001111110010101000101001011110001011101010011111011110101011010011110000001111100100010110011001001001010011111000000000111100010111011000110101111101011111001010111101100101111011010010010110110000100001111011011001100011110100111111101001101110100011010110100001110111101110101000101111001011011111010000011100011110100111111100000000011111101011101111001010010001111000100011111001010100111101011101010010101011100111011011001010111111010111001100111011100010111100010101001111101110100001011110000010101110101101111000101000010110111111010110011011110100001011111110010011011100000001111100110000000001110111110100011010110001100011001000110110100001110101101111000101000000111101000000000101101100010111001111100110011010010010011101101110000101111010111111010000110011101100110010000010111111100000001010100011110000000001111100101101011010111000001010011111001011001000101010000010111000100111101001100100111110010111000101111000001110110110111010001010010010101111100111000110111010110001011001011111110110110111010101001011000111011101010011000100111000010101001000001011010010100010010100110001111101110110111001011011110001100111110000000001111110000000101010011100110010110010101001111110010101001111010111010101100111100111010010101001110110101100000101001111001110001100101101100101011101000010001001110100011001001000010111100000001110110001110000010111011110111000101010000010111111110100101101010111111000000010100110010101001011111110110110111110101110111100101001000111100010001011110010110111110101101010001000001110110110011100010011110100111111100100100110011100111111010011111101011110100101100111001110111110001111010101010111011101001001001011111101000110110110111001010010001111000101010001011110010110111101001100100111111010100011110100100111011110001111011011001010011011101001111000110110001111000100000011110110010101101111100101010011011100010111011000110101111101011111010011001001111000101110110001101011111010110110111010111000100111100000000011110100000000010110110001011100111101110010011110100011010011011110110110001100100010111000101011010010011001111110100101011000100101111100111010011100001111000110011111000000010110111111010100101010111001100011110110010101101010001</span><br><span class="line"></span><br><span class="line">The Chinese official said he viewed the Trump Presidency not as an</span><br><span class="line">aberration but as the product of a failing political system. This jibes with other</span><br><span class="line">accounts. The Chinese leadership believes that the United States, and Western</span><br><span class="line">democracies in general, haven’t risen to the challenge of a globalized economy,</span><br><span class="line">which necessitates big changes in production patterns, as well as major upgrades</span><br><span class="line">in education and public infrastructure. In Trump and Trumpism, the Chinese see</span><br><span class="line">an inevitable backlash to this failure.</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://8023time.github.io">寻觅~流光</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://8023time.github.io/2024/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%BA%8C/">https://8023time.github.io/2024/11/26/数据结构-实验二/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://8023time.github.io" target="_blank">寻觅~流光</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/basic-img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/basic-img/wechat.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2024/11/26/%E5%8A%A8%E6%80%81%E7%88%B1%E5%BF%83/" title="动态爱心♥"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Interesting-webpage-image/20241126170116.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">动态爱心♥</div></div></a><a class="next-post pull-right" href="/2024/11/25/%E6%B0%B4%E5%A2%A8%E7%94%BB%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/" title="水墨画网页"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Interesting-webpage-image/20241126095152.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">水墨画网页</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2024/11/20/%E6%89%8B%E6%92%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%9F%E5%88%97,%E4%BB%A5%E5%AE%9E%E7%8E%B0BFS%E7%AE%97%E6%B3%95,%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%8E%9F%E6%9C%89%E7%9A%84queue/" title="数据结构queue实现BFS"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="title">数据结构queue实现BFS</div></div></a><a href="/2024/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%B8%89/" title="数据结构-实验三"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-11</div><div class="title">数据结构-实验三</div></div></a><a href="/2024/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%B8%80/" title="数据结构-实验一"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-22</div><div class="title">数据结构-实验一</div></div></a><a href="/2024/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8412-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/" title="数据结构12-二叉排序树"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-29</div><div class="title">数据结构12-二叉排序树</div></div></a><a href="/2024/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8413-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构13-平衡二叉树"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-30</div><div class="title">数据结构13-平衡二叉树</div></div></a><a href="/2024/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8414-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/" title="数据结构14-哈夫曼树"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-30</div><div class="title">数据结构14-哈夫曼树</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/basic-img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">寻觅~流光</div><div class="author-info-description">吾不复我......</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/8023time"><i class="fab fa-github"></i><span>我的GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><div style="text-align:center">云雾依稀折柳枝,<br>凭栏更待青云月.<br>请君莫辞凌烟走,<br>惟愿神秀尽前时.</div><div style="text-align:right">-----2023年6月8日</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%BA%8C"><span class="toc-number">1.</span> <span class="toc-text">数据结构-实验二</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">二叉树的操作与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">1、二叉树的基本操作算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.1.0.1.</span> <span class="toc-text">2.参考数据:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8F%82%E8%80%83%E7%BB%93%E6%9E%9C"><span class="toc-number">1.1.1.0.2.</span> <span class="toc-text">3.参考结果:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%84%E7%A7%8D%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、二叉树的各种遍历算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%85%88%E5%BA%8F-%E4%B8%AD%E5%BA%8F%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.2.0.1.</span> <span class="toc-text">1.先序,中序的非递归遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.0.2.</span> <span class="toc-text">2.后序遍历的非递归的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">3、线索二叉树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91HT%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81HC%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E8%AF%91%E7%A0%81%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E3%80%82"><span class="toc-number">1.1.4.</span> <span class="toc-text">4、构造哈夫曼树HT、哈夫曼编码HC、哈夫曼译码的算法实现。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE-1"><span class="toc-number">1.1.4.0.1.</span> <span class="toc-text">2.参考数据:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8F%82%E8%80%83%E7%BB%93%E6%9E%9C-1"><span class="toc-number">1.1.4.0.2.</span> <span class="toc-text">3.参考结果:</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/14/%E9%80%92%E5%BD%92/" title="递归"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/JavaScript-image/JavaScript%E5%9B%BE%E7%89%87.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="递归"></a><div class="content"><a class="title" href="/2024/12/14/%E9%80%92%E5%BD%92/" title="递归">递归</a><time datetime="2024-12-13T16:00:00.000Z" title="发表于 2024-12-14 00:00:00">2024-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E5%9B%9B/" title="数据结构-实验四"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="数据结构-实验四"></a><div class="content"><a class="title" href="/2024/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E5%9B%9B/" title="数据结构-实验四">数据结构-实验四</a><time datetime="2024-12-13T16:00:00.000Z" title="发表于 2024-12-14 00:00:00">2024-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/11/2024%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AFCC++B%E7%BB%84/" title="2024第十五届蓝桥杯C/C++B组"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Blue-Bridge-Cup-image/20241211191421.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="2024第十五届蓝桥杯C/C++B组"></a><div class="content"><a class="title" href="/2024/12/11/2024%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AFCC++B%E7%BB%84/" title="2024第十五届蓝桥杯C/C++B组">2024第十五届蓝桥杯C/C++B组</a><time datetime="2024-12-10T16:00:00.000Z" title="发表于 2024-12-11 00:00:00">2024-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%B8%89/" title="数据结构-实验三"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/Data-structure-image/20241125232235.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="数据结构-实验三"></a><div class="content"><a class="title" href="/2024/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C%E4%B8%89/" title="数据结构-实验三">数据结构-实验三</a><time datetime="2024-12-10T16:00:00.000Z" title="发表于 2024-12-11 00:00:00">2024-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/8023time/image-storage-address/JavaScript-image/JavaScript%E5%9B%BE%E7%89%87.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="动态规划"></a><div class="content"><a class="title" href="/2024/12/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a><time datetime="2024-12-09T16:00:00.000Z" title="发表于 2024-12-10 00:00:00">2024-12-10</time></div></div></div></div></div></div></main><footer id="footer" style="background:0 0"><div id="footer-wrap"><div class="copyright">&copy;2024 By 寻觅~流光</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"left",width:200,height:400},mobile:{show:!1},log:!1})</script></body></html>